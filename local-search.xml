<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>实训第二天</title>
    <link href="/2021/06/23/day02/"/>
    <url>/2021/06/23/day02/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="day02"><a href="#day02" class="headerlink" title="day02"></a>day02</h1><h3 id="一、继承"><a href="#一、继承" class="headerlink" title="一、继承"></a>一、继承</h3><h4 id="1-1-注意事项"><a href="#1-1-注意事项" class="headerlink" title="1.1 注意事项"></a>1.1 注意事项</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 父类中的私有成员不能被继承（父类中的私有成员可以被继承，但是无法访问）<br><span class="hljs-bullet">2.</span> 父类中的构造方法无法被继承。为什么？<br><span class="hljs-bullet">1.</span> 父类中的构造方法名和父类类名一致，子类的构造方法名和子类类名一致，所以无法使用<br><span class="hljs-bullet">2.</span> 子类中构造方法初试化的内容不会比父类中的少，所以无法使用<br></code></pre></td></tr></table></figure><h4 id="1-2-特点"><a href="#1-2-特点" class="headerlink" title="1.2 特点"></a>1.2 特点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-number">1.</span> 可以单继承<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fu</span> </span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Zi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fu</span> </span>&#123;&#125;<br><span class="hljs-number">2.</span> 不可以多继承<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fu</span> </span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Mu</span> </span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Zi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fu</span>, <span class="hljs-title">Mu</span> </span>&#123;&#125;         <span class="hljs-comment">//错误</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Zi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fu</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Mu</span> </span>&#123;&#125;  <span class="hljs-comment">//错误</span><br><span class="hljs-number">3.</span> 可以多层继承（继承体系）<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Ye</span> </span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Fu</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Ye</span> </span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Zi</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Fu</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><h4 id="1-3-继承中成员变量之间的关系"><a href="#1-3-继承中成员变量之间的关系" class="headerlink" title="1.3 继承中成员变量之间的关系"></a>1.3 继承中成员变量之间的关系</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 如果父类中的成员变量名和子类中的成员变量名不一致的话，那么直接根据不同的变量名访问即可<br><span class="hljs-bullet">2.</span> 如果父类中的成员变量名和子类中的成员变量名一致的话，那么有如下访问规律：<br><span class="hljs-code">先在子类的局部访问查找，如果找到就使用，如果找不到就去子类的成员位置去找</span><br><span class="hljs-code">如果在子类的成员位置找到了，那么就使用，如果找不到那么就去父类的成员位置去找</span><br><span class="hljs-code">如果在父类的成员位置找到了，那么就使用，如果找不到就报错（不考虑父类还有父类的情况）</span><br><span class="hljs-code">父类的局部位置根本访问不到。</span><br></code></pre></td></tr></table></figure><h4 id="1-4-继承中成员方法之间的关系"><a href="#1-4-继承中成员方法之间的关系" class="headerlink" title="1.4 继承中成员方法之间的关系"></a>1.4 继承中成员方法之间的关系</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 如果父类中的成员方法名和子类中的成员方法名不一致，那么直接根据不同的方法名访问即可<br><span class="hljs-bullet">2.</span> 如果父类中的成员方法名和子类中的成员方法名一致，那么有如下访问规律：<br><span class="hljs-code">如果子类中的方法声明和父类中完全一致，那么就会发生方法的重写现象，并且访问的是重写后的内容</span><br><span class="hljs-code">如果子类中的方法参数和父类中的方法参数不一致，那么也相当于是不同的方法，直接根据不同的方法访问即可。</span><br><span class="hljs-code"></span><br>方法重载和方法重写的区别？<br><span class="hljs-code">方法重载：在同一个类中，方法名相同，参数列表不同，与返回值类型无关。   @Overload</span><br><span class="hljs-code">参数列表不同的三种情况：</span><br><span class="hljs-code">个数不同</span><br><span class="hljs-code">类型不同</span><br><span class="hljs-code">位置不同</span><br><span class="hljs-code">方法重写：在继承关系中，方法名相同，参数列表也相同，与返回值类型有关。 @Override</span><br></code></pre></td></tr></table></figure><h4 id="1-5-继承中构造方法之间的关系"><a href="#1-5-继承中构造方法之间的关系" class="headerlink" title="1.5 继承中构造方法之间的关系"></a>1.5 继承中构造方法之间的关系</h4><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs scss">已知子类在使用构造方法之前会先访问父类的无参构造方法。如果父类没有无参构造方法怎么办？<br>1. 让子类的第一行通过super(...);去访问父类的带参构造方法<br>2. 可以让子类中的一个构造方法访问父类的带参构造方法，然后子类的其它构造方法访问这个构造方法即可。<br><br>注意：<br>1. 构造方法的第一行默认带有一个super();访问父类的无参构造方法<br>2. super()和this()访问构造方法的时候，都只能放在构造方法中的第一行<br>3. super()和this()不能共存<br>4. 我们书写一个新的super()和this()会将默认的给覆盖掉<br></code></pre></td></tr></table></figure><h3 id="二、抽象类"><a href="#二、抽象类" class="headerlink" title="二、抽象类"></a>二、抽象类</h3><blockquote><p>就是用关键字abstract修饰的类</p></blockquote><h4 id="2-1-格式"><a href="#2-1-格式" class="headerlink" title="2.1 格式"></a>2.1 格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> 类名 </span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-注意事项"><a href="#2-2-注意事项" class="headerlink" title="2.2 注意事项"></a>2.2 注意事项</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 抽象类有构造方法，但是不能创建对象。那么如何创建对象呢？<br><span class="hljs-code">定义抽象类的子类，并创建子类的对象。</span><br><span class="hljs-code">2. 抽象类中可以放抽象方法</span><br><span class="hljs-code">3. 抽象方法一定要放在抽象类中</span><br><span class="hljs-code"></span><br>抽象方法：<br><span class="hljs-code">修饰符 abstract 返回值类型 方法名(参数列表);</span><br></code></pre></td></tr></table></figure><h4 id="2-3-抽象类中成员"><a href="#2-3-抽象类中成员" class="headerlink" title="2.3 抽象类中成员"></a>2.3 抽象类中成员</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs">成员变量：普通的成员变量、私有的成员变量、静态变量、常量<br>成员方法：普通的成员方法、抽象方法<br>构造方法：有，但是不可以创建对象。<br>主要用来初始化成员，方便子类的调用<br></code></pre></td></tr></table></figure><h4 id="2-4-如何处理抽象中的抽象方法"><a href="#2-4-如何处理抽象中的抽象方法" class="headerlink" title="2.4 如何处理抽象中的抽象方法"></a>2.4 如何处理抽象中的抽象方法</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">注意：抽象方法最后肯定会被重写的。如果不重写就报错。所以抽象方法有强制使用的效果。<br></code></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/motianji004/blogimage/img/20210623094536.png" alt="image-20210622101429473"></p><h3 id="三、接口"><a href="#三、接口" class="headerlink" title="三、接口"></a>三、接口</h3><blockquote><p>定义了一组规范。 </p></blockquote><h4 id="3-1-格式"><a href="#3-1-格式" class="headerlink" title="3.1 格式"></a>3.1 格式</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">关键字：<span class="hljs-class"><span class="hljs-keyword">interface</span></span><br><span class="hljs-class"></span><br><span class="hljs-class"><span class="hljs-title">interface</span> 接口名 </span>&#123;<br><br>&#125;<br><br>注意：和类一样，也会生成一个<span class="hljs-class"><span class="hljs-keyword">class</span>文件</span><br></code></pre></td></tr></table></figure><h4 id="3-2-注意事项"><a href="#3-2-注意事项" class="headerlink" title="3.2 注意事项"></a>3.2 注意事项</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">接口没有构造方法，不能创建对象。那么接口如何创建对象呢？<br>定义一个实现类，然后通过关键字implements实现接口，格式如下：<br><span class="hljs-class"><span class="hljs-keyword">interface</span> 接口名 </span>&#123;<br><br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> 实现类 <span class="hljs-keyword">implements</span> 接口名 </span>&#123;<br><br>&#125;<br>然后再创建实现类的对象即可<br></code></pre></td></tr></table></figure><h4 id="3-3-接口中的成员"><a href="#3-3-接口中的成员" class="headerlink" title="3.3 接口中的成员"></a>3.3 接口中的成员</h4><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs aspectj">成员变量：默认就是常量，并且默认被<span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span>修饰<br>成员方法：默认就是抽象方法，并且默认被<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span>修饰<br>jdk8之后： 接口中可以放被<span class="hljs-keyword">static</span>和<span class="hljs-keyword">default</span>修饰的方法<br>jdk9之后： 接口中可以放被<span class="hljs-keyword">private</span>修饰的方法<br>构造方法：没有。<br>因为接口中的变量默认都是常量、方法都是抽象的（而抽象方法肯定是要被重写的）。所以不需要初始化<br></code></pre></td></tr></table></figure><h3 id="四、多态"><a href="#四、多态" class="headerlink" title="四、多态"></a>四、多态</h3><blockquote><p>多态就是一个物体的多种形态。</p><p>自然界中的事物比如：猫、狗、大象它们都会跑，但是跑的方式不一样。再比如：鸟、昆虫、飞机都会飞，但是飞的方式不一样。这就是多态。</p></blockquote><h4 id="4-1-概念"><a href="#4-1-概念" class="headerlink" title="4.1 概念"></a>4.1 概念</h4><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">在Java中，多态就是对于同一个命令（方法），有不同的执行方式（内容）。<br></code></pre></td></tr></table></figure><h4 id="4-2-前提"><a href="#4-2-前提" class="headerlink" title="4.2 前提"></a>4.2 前提</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 有继承或者实现<br><span class="hljs-bullet">2.</span> 有方法的重写（如果没有方法重写，那么多态的意义就没有了）<br><span class="hljs-bullet">3.</span> 父类的引用指向子类的对象<br></code></pre></td></tr></table></figure><h4 id="4-3-多态中成员的访问规律"><a href="#4-3-多态中成员的访问规律" class="headerlink" title="4.3 多态中成员的访问规律"></a>4.3 多态中成员的访问规律</h4><blockquote><p>Fu f = new Zi();</p><p>等号的左边：父类的引用f</p><p>等号的右边：子类的对象new Zi();</p><p>探究的时候，注意以下两点：编译是否报错，运行的结果是子类的还是父类的</p></blockquote><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs awk">成员变量：编译看左边（就是父类中有没有，如果有就不报错），运行看左边（运行的是父类中的结果）<br>成员方法：编译看左边（就是父类中有没有，如果有就不报错），运行看右边（运行的是子类中重写后的结果）<br><br>参考文档：https:<span class="hljs-regexp">//</span>www.techiedelight.com<span class="hljs-regexp">/difference-between-early-late-binding-java/</span><br></code></pre></td></tr></table></figure><h4 id="4-4-类与类、类与接口、接口与接口之间的关系"><a href="#4-4-类与类、类与接口、接口与接口之间的关系" class="headerlink" title="4.4 类与类、类与接口、接口与接口之间的关系"></a>4.4 类与类、类与接口、接口与接口之间的关系</h4><h5 id="类与类"><a href="#类与类" class="headerlink" title="类与类"></a>类与类</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 可以单继承<br><span class="hljs-bullet">2.</span> 不可以多继承<br><span class="hljs-bullet">3.</span> 可以多层继承<br></code></pre></td></tr></table></figure><h5 id="类与接口"><a href="#类与接口" class="headerlink" title="类与接口"></a>类与接口</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 可以单实现<br><span class="hljs-bullet">2.</span> 可以多实现<br></code></pre></td></tr></table></figure><h5 id="接口与接口"><a href="#接口与接口" class="headerlink" title="接口与接口"></a>接口与接口</h5><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 可以单继承<br><span class="hljs-bullet">2.</span> 可以多继承<br><br>注意：一个类可以在单继承一个类之后，再多实现接口<br></code></pre></td></tr></table></figure><h4 id="4-5-多态的好处"><a href="#4-5-多态的好处" class="headerlink" title="4.5 多态的好处"></a>4.5 多态的好处</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">1.</span> 增加了代码的可维护性 （由继承保证）<br><span class="hljs-bullet">2.</span> 增加了代码的可扩展性 （由多态保证）<br></code></pre></td></tr></table></figure><h4 id="4-6-多态的弊端"><a href="#4-6-多态的弊端" class="headerlink" title="4.6 多态的弊端"></a>4.6 多态的弊端</h4><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs markdown">在多态中，不能访问子类独有的功能（也就是父类中没有，而子类中有的方法）。那么如何处理？<br><span class="hljs-bullet">1.</span> 直接创建一个子类的对象，并通过子类对象访问<br><span class="hljs-bullet">2.</span> 将父类的引用直接强转为子类对象（以为父类的引用指向的本来就是子类的对象，所以可以强转）<br></code></pre></td></tr></table></figure><h4 id="4-7-向上转型和向下转型"><a href="#4-7-向上转型和向下转型" class="headerlink" title="4.7 向上转型和向下转型"></a>4.7 向上转型和向下转型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">向上转型：由较小的类型转为较大的类型<br>Fu f = <span class="hljs-keyword">new</span> Zi();<br>向下转型：由较大的类型转为较小的类型<br>Zi z = (Zi)f;<br><br>关键字：<span class="hljs-keyword">instanceof</span>可以判断一个对象是否属于某一个类型。<br>使用格式如下：<br>对象 <span class="hljs-keyword">instanceof</span> 类或者接口<br>如果属于结果为<span class="hljs-keyword">true</span>，否则结果为<span class="hljs-keyword">false</span><br></code></pre></td></tr></table></figure><h4 id="4-8-多态在形式参数和返回值上的应用"><a href="#4-8-多态在形式参数和返回值上的应用" class="headerlink" title="4.8 多态在形式参数和返回值上的应用"></a>4.8 多态在形式参数和返回值上的应用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Animal</span> </span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dog</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Cat</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Animal</span> </span>&#123;&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        test(<span class="hljs-keyword">new</span> Dog());<br>        test(<span class="hljs-keyword">new</span> Cat());<br><br>        Dog animal = (Dog) getAnimal();<br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        注意事项：</span><br><span class="hljs-comment">            1. 如果形式参数需要的是类这种类型，那么实际上需要的是该类的对象</span><br><span class="hljs-comment">            2. 可以接收的参数为该类的对象，或者该类的所有子类对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(Animal a)</span></span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">        注意事项：</span><br><span class="hljs-comment">            1. 如果返回值类型为类这种类型，实际上需要的是该类的对象</span><br><span class="hljs-comment">            2. 可以返回的值有该类的对象，或者该类的所有子类的对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Animal <span class="hljs-title">getAnimal</span><span class="hljs-params">()</span></span>&#123;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Dog();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs mipsasm">练习：员工类的练习，用抽象类和继承完成<br><span class="hljs-keyword">Java程序员 </span>（属性：姓名、工号、工资、奖金）  （行为：工作 写<span class="hljs-keyword">bug）</span><br><span class="hljs-keyword"></span>测试程序员  （属性：姓名、工号、工资）       （行为：工作 改<span class="hljs-keyword">bug）</span><br><span class="hljs-keyword"></span>项目经理    （属性：姓名、工号、工资、奖金）  （行为：工作 控制写和改<span class="hljs-keyword">bug的进度）</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*</span><br><span class="hljs-comment">    练习：员工类的练习，用抽象类和继承完成</span><br><span class="hljs-comment">        Java程序员 （属性：姓名、工号、工资、奖金）  （行为：工作 写bug）</span><br><span class="hljs-comment">        测试程序员  （属性：姓名、工号、工资）       （行为：工作 改bug）</span><br><span class="hljs-comment">        项目经理    （属性：姓名、工号、工资、奖金）  （行为：工作 控制写和改bug的进度）</span><br><span class="hljs-comment"> */</span><br><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Worker</span> </span>&#123;<br><br>    String name;<br>    <span class="hljs-keyword">int</span> id;<br>    <span class="hljs-keyword">int</span> salary;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printInfo</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(name + <span class="hljs-string">&quot;---&quot;</span> + id + <span class="hljs-string">&quot;---&quot;</span> + salary);<br>    &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JavaWorker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Worker</span> </span>&#123;<br><br>    <span class="hljs-keyword">int</span> bonus;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">JavaWorker</span><span class="hljs-params">()</span></span>&#123;<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">JavaWorker</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> salary, <span class="hljs-keyword">int</span> bonus)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.id = id;<br>        <span class="hljs-keyword">this</span>.salary = salary;<br>        <span class="hljs-keyword">this</span>.bonus = bonus;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;写bug&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printInfo</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>.printInfo();<br>        System.out.println(<span class="hljs-string">&quot;奖金为：&quot;</span> + bonus);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestWorker</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Worker</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TestWorker</span><span class="hljs-params">()</span></span>&#123;<br><br>    &#125;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TestWorker</span><span class="hljs-params">(String name, <span class="hljs-keyword">int</span> id, <span class="hljs-keyword">int</span> salary)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>        <span class="hljs-keyword">this</span>.id = id;<br>        <span class="hljs-keyword">this</span>.salary = salary;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;找Bug&quot;</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Demo2</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        JavaWorker jw = <span class="hljs-keyword">new</span> JavaWorker(<span class="hljs-string">&quot;雷军&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">100000</span>, <span class="hljs-number">1000000000</span>);<br>        jw.work();<br>        jw.printInfo();<br><br>        TestWorker tw = <span class="hljs-keyword">new</span> TestWorker(<span class="hljs-string">&quot;周鸿祎&quot;</span>, <span class="hljs-number">1</span>, <span class="hljs-number">100000</span>);<br>        tw.work();<br>        tw.printInfo();<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>测试</title>
    <link href="/2021/06/22/%E6%B5%8B%E8%AF%95/"/>
    <url>/2021/06/22/%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="1-第二天"><a href="#1-第二天" class="headerlink" title="1.第二天"></a>1.第二天</h3><p><img src="https://raw.githubusercontent.com/motianji004/blogimage/main/img/dzq.jpg"></p><p><img src="https://raw.githubusercontent.com/motianji004/blogimage/main/img/QQ%E6%88%AA%E5%9B%BE20191024104414.png"></p>    <div id="aplayer-rlTHFGFh" class="aplayer aplayer-tag-marker meting-tag-marker"         data-id="7629115" data-server="netease" data-type="playlist" data-mode="circulation" data-autoplay="true" data-mutex="false" data-listmaxheight="340px" data-preload="none" data-theme="#ad7a86"    ></div>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>网络工程复习</title>
    <link href="/2021/06/22/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B/"/>
    <url>/2021/06/22/%E7%BD%91%E7%BB%9C%E5%B7%A5%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h3 id="第一章-交换网络"><a href="#第一章-交换网络" class="headerlink" title="第一章 交换网络"></a>第一章 交换网络</h3><p>我国的互联网主要是依靠风险投资，自身并不能创造价值，出现冬天是必然的，那么，互联网的赢利之道在哪里？**网络工程复习</p><p>答：       </p><p>“新冠”会帮谁的忙？即：从技术的角度来看，新冠给我们带来了什么</p><p>答：</p><h4 id="交换机的工作原理"><a href="#交换机的工作原理" class="headerlink" title="交换机的工作原理"></a>交换机的工作原理</h4><p>当交换机收到数据时，它会检查它的目的MAC地址，然后把数据从目的主机所在的接口转发出去。交换机之所以能实现这一功能，是因为交换机内部有一个MAC地址表，MAC地址表记录了网络中所有MAC地址与该交换机各端口的对应信息。某一数据帧需要转发时，交换机根据该数据帧的目的MAC地址来查找MAC地址表，从而得到该地址对应的端口，即知道具有该MAC地址的设备是连接在交换机的哪个端口上，然后交换机把数据帧从该端口转发出去。</p><p>1.交换机根据收到数据帧中的源MAC地址建立该地址同交换机端口的映射，并将其写入MAC地址表中。<br>2.交换机将数据帧中的目的MAC地址同已建立的MAC地址表进行比较，以决定由哪个端口进行转发。<br>3.如数据帧中的目的MAC地址不在MAC地址表中，则向所有端口转发。这一过程称为泛洪（flood）。<br>4.广播帧和组播帧向所有的端口转发。</p><h4 id="共享式以太网和交换式以太网"><a href="#共享式以太网和交换式以太网" class="headerlink" title="共享式以太网和交换式以太网"></a>共享式以太网和交换式以太网</h4><p>总线型和星型</p><p>交换机，隔离冲突域</p><h4 id="广播域和冲突域"><a href="#广播域和冲突域" class="headerlink" title="广播域和冲突域"></a>广播域和冲突域</h4><p>广播帧可达区域，一个局域网往往是一个广播域</p><p>不同时收发数据</p><h4 id="以太网的最小帧长"><a href="#以太网的最小帧长" class="headerlink" title="以太网的最小帧长"></a>以太网的最小帧长</h4><p>64</p><p>1518</p><p> 802.3标准将长度达到最大值的以太网两倍往返时延取为51.2μs = (2500*4)/((1.9~2.4)*10**8)s. </p><p>千兆交换机转发速率：1.488Mpps</p><p>(1000M/8bit/(64+8+12))</p><h4 id="交换机的交换方式"><a href="#交换机的交换方式" class="headerlink" title="交换机的交换方式"></a>交换机的交换方式</h4><p>1.直通式</p><p>​     直接转发，不校验，收发端口速率不匹配时容易丢帧</p><p>2.存储转发</p><p>​     先校验再转发，有效协调收发端口速率不匹配问题，速度慢  </p><p>​     即与源地址处于同一网桥端口，交换机不转发该数据帧，而是直接丢弃。  </p><h4 id="交换机环路是MAC地址系统失效"><a href="#交换机环路是MAC地址系统失效" class="headerlink" title="交换机环路是MAC地址系统失效"></a>交换机环路是MAC地址系统失效</h4><p>l由于交换机不允许两个端口有相同的MAC地址，所以交换机会不断用源MAC地址，更新MAC地址表，MAC地址系统失效。</p><h4 id="交换机的级联和堆叠"><a href="#交换机的级联和堆叠" class="headerlink" title="交换机的级联和堆叠"></a>交换机的级联和堆叠</h4><p>1、通过堆叠，可以扩展端口密度。</p><p>2、方便用户的管理操作。用户可以将一组交换机作为一个逻辑对象，通过一个IP来管理，减少IP地址的占用并方便管理。</p><p>3、扩展上链带宽。如8台交换机堆叠，上链可以有8个千兆端口，8个千兆口形成聚合端口，带宽可以达到8Gbps。</p><p>缺点</p><p>1、堆叠交换机的数目有限制，一般最多8台。</p><p>2、要求堆叠成员离自己的位置足够近，一般在同一机柜中。</p><p>注意：</p><p>1、堆叠只能在同一厂商且具有堆叠。。</p><p>2、数目限制</p><p>3、级联有上下集关系，性能不同，不能增加交换速度</p><p>4、逻辑上，级联单独，堆叠看成一个</p><p>5、距离限制</p><p>双绞线：568A:绿蓝橙棕，白色在前，三五交换</p><h4 id="双绞线100米传输极限的原因"><a href="#双绞线100米传输极限的原因" class="headerlink" title="双绞线100米传输极限的原因"></a>双绞线100米传输极限的原因</h4><p>1、信号传输时，电阻和电容会导致信号衰减或畸变。</p><p>2．信号在导线传输过程中既会产生彼此之间的相互干扰，也会受到外界电磁波的干扰，</p><p>3．以太网所允许的最大延迟为512比特时间（1比特时间=10纳秒）。</p><p>4．根据IEEE 802.3标准要求，集线设备和网卡端口的PHY芯片只保证驱动100米的铜缆，对更远的传输距离则不作保证。</p><h3 id="第二章-虚拟局域网技术"><a href="#第二章-虚拟局域网技术" class="headerlink" title="第二章 虚拟局域网技术"></a>第二章 虚拟局域网技术</h3><p>VLAN编号：1~1005</p><p>1，1002~1005特殊用处</p><p>•例外：当交换机需要从Trunk接口发送的数据帧VLAN标签与这个Trunk接口的PVID相同，交换机会以不携带VLAN标签的方式来发送这个数据帧。</p><p>VLAN总结：</p><p>VLAN可以有效地隔离广播域</p><p>VLAN更安全</p><p>l现有网卡不需要更换，因为有终端连接的第一台交换机负责生成/去除VLAN新帧</p><p>帧长由1518-&gt;1522(4字节tag)</p><h3 id="第三章-生成树协议"><a href="#第三章-生成树协议" class="headerlink" title="第三章 生成树协议"></a>第三章 生成树协议</h3><p>消除环路</p><p>链路备份</p><p>阻塞状态：     当一个端口阻止流量进入或离开时，该端口便视为处于阻塞状态。不过 STP 用来防止环路的网桥协议数据单元 (BPDU) 帧仍可继续通行。  </p><p>路径开销：</p><p><img src="C:\Users\陌生的回忆\AppData\Roaming\Typora\typora-user-images\1620699797802.png" alt="1620699797802"></p><p>​     根端口存在于非根桥上，该端口具有到根桥的最佳路径。  </p><p>分配端口：</p><p>如果两个交换机端口到根桥的路径开销相同而且都是最低开销，交换机需要确定哪一个成为根端口。此时，交换机通过可自定义的端口优先级值来加以确定；如果两个端口的优先级值相同，则通过最低端口 ID 来确定。</p><p><img src="C:\Users\陌生的回忆\AppData\Roaming\Typora\typora-user-images\1620701207905.png" alt="1620701207905"></p><p><img src="C:\Users\陌生的回忆\AppData\Roaming\Typora\typora-user-images\1620701300001.png" alt="1620701300001"></p><p>3.这种状态在图中出现了2次，即从侦听过渡到学习，以及从学习过渡到转发。转发延迟计时器默认为15秒，端口一旦进入到侦听状态（或学习状态），必须等待15秒才能过渡到学习状态（或转发状态）</p><p>•侦听到学习：计算整个STP需要时间</p><p>•学习到转发：学习MAC地址转发表需要时间</p><p>l转发延迟超时事件：</p><p>•以时间作为是否迁移到下一状态的评判标准，其他事件只要发生，端口会立即切换STP状态；</p><p>•确保了当网络中STP端口状态发生变化时，不会产生临时环路。</p><p>对点对点有效：P/A机制：是RSTP的最大特点</p><p>指定端口与对端握手，并逐级传递</p><table><thead><tr><th><strong>RSTP****状态</strong></th><th><strong>传统<strong><strong>STP</strong></strong>状态</strong></th><th><strong>功能</strong></th></tr></thead><tbody><tr><td>Discarding  （丢弃状态）</td><td>Disabled  （禁用状态）</td><td>这种状态表示此端口未启用。</td></tr><tr><td></td><td>Blocking  （阻塞状态）</td><td>这种状态表示此端口会忽略入站数据帧，同时也不会转发数据帧。</td></tr><tr><td></td><td>侦听</td><td>这种状态表示此端口既不会学习MAC地址，也不会转发数据帧。</td></tr><tr><td>Learning  （学习状态）</td><td>Learning  （学习状态）</td><td>这种状态表示此端口会学习MAC地址，但不会转发数据帧。</td></tr><tr><td>Forwarding  （转发状态）</td><td>Forwarding  （转发状态）</td><td>这种状态表示此端口既会学习MAC地址，也会转发数据帧。</td></tr></tbody></table><h3 id="第四章-静态路由"><a href="#第四章-静态路由" class="headerlink" title="第四章 静态路由"></a>第四章 静态路由</h3><p> 直连路由的路由优先级和度量值都是不可修改的  ，均为0</p><p>串口（Serial）直连两端都配置IP地址之后，路由表才会出现；</p><p>稳定可控容易部署</p><p>扩展性差</p><p>无法反映拓扑的变化</p><p>​     <strong>特别注意：两个相邻路由器不能互相设置默认路由，否则会出现环路</strong>  </p><p><strong>网络汇总的优势：</strong></p><p>•减小了路由条目的数量 ；</p><p>•降低了路由设备资源的消耗；</p><p>•提高了网络基础设施的转发效率；</p><p>•突出了IP地址作为逻辑地址的可汇总优势。</p><p><img src="https://raw.githubusercontent.com/motianji004/blogimage/main/img/1620726909201.png" alt="1620726909201"></p><p><img src="C:\Users\陌生的回忆\AppData\Roaming\Typora\typora-user-images\1620726918997.png" alt="1620726918997"></p><p><img src="https://raw.githubusercontent.com/motianji004/blogimage/main/img/1620726935720.png" alt="1620726935720"></p><p><img src="C:\Users\陌生的回忆\AppData\Roaming\Typora\typora-user-images\1620727016324.png" alt="1620727016324"></p><p><img src="C:\Users\陌生的回忆\AppData\Roaming\Typora\typora-user-images\1620727022888.png" alt="1620727022888"></p><p><img src="C:\Users\陌生的回忆\AppData\Roaming\Typora\typora-user-images\1620727030074.png" alt="1620727030074"></p><p>配置两条目的网络一样而下一跳不一样但优先级不同的静态路由可以实现主备用的作用，而设置优先级相同时则可以实现负载均衡。</p><h3 id="第五章-VLAN间路由"><a href="#第五章-VLAN间路由" class="headerlink" title="第五章 VLAN间路由"></a>第五章 VLAN间路由</h3><p>•通过拥有三层功能的设备所提供的路由机制来为不同VLAN中的设备路由数据包的设计方案称为VLAN间路由。</p><h4 id="单臂路由："><a href="#单臂路由：" class="headerlink" title="单臂路由："></a>单臂路由：</h4><p>•交换机与路由器只用一个接口互联；</p><p>•交换机上的所有VLAN间数据都从这个接口进行转发；</p><p>•这组组网环境称为单臂路由。</p><p><img src="C:\Users\陌生的回忆\AppData\Roaming\Typora\typora-user-images\1620784246102.png" alt="1620784246102"></p><p>物理上一个接口，逻辑上划分为多个子接口</p><p><img src="C:\Users\陌生的回忆\AppData\Roaming\Typora\typora-user-images\1620784324550.png" alt="1620784324550"></p><p>interface g0/0/0.10</p><p>dot1q termination vid 10</p><p>ip adress 10.0.10.254 24</p><p>arp boradcast enable</p><p>l通过命令<strong>interface</strong> <em>interface-type interface-<strong>number.sub</strong>-interface number</em>创建了子接口并进入子接口配置视图。华为路由器上子接口编号的配置范围是1～4096。我们将子接口编号与VLAN ID保持了统一，这是为了增强配置的可读性。</p><p>l在两个子接口的子接口配置视图下分别使用命令<strong>dot1q termination</strong> <em>vid</em>为它们配置了802.1Q封装并且指定了端口的PVID。鉴于对端的交换机端口会执行802.1Q封装，因此这条命令的目的正是为了确保路由器子接口能够与对端的交换机端口封装模式一致。当接口配置了这条命令后，接口在收发数据帧时的处理原则是：接收数据帧时，路由器会剥除数据帧中携带的VLAN标签，之后进行三层转发；在向外转发数据帧时，是否带VLAN标签由出站接口决定。当这个接口发送数据帧时，路由器会将相应的VLAN标签添加到数据帧中再进行发送。</p><p>l命令<strong>arp</strong> <strong>broadcast enable</strong>能够启用子接口的ARP广播功能。在默认情况下，ARP广播功能是禁用的，也就是说子接口在接收到ARP广播帧后会直接丢弃。为了使子接口能够处理广播数据帧，管理员就需要在子接口上配置这条命令。</p><p>vlan batch 10 20</p><p>port trunk allow-pass vlan 10 20</p><h4 id="三层交换机："><a href="#三层交换机：" class="headerlink" title="三层交换机："></a>三层交换机：</h4><p>•集成了三层数据包转发功能的交换机被称为三层交换机；</p><p>•可以实现将终端隔离在不同VLAN中，同时为这些终端提供VLAN间路的功能；</p><p>•随着通过ASIC（和网络处理器）开始大量应用于路由器，路由器和交换机之间的界限已经变得十分模糊。</p><p>vlan batch 10 20</p><p>interface vlanif 10</p><p>其余和传统类似</p><h5 id="虚拟VLAN接口："><a href="#虚拟VLAN接口：" class="headerlink" title="虚拟VLAN接口："></a>虚拟VLAN接口：</h5><p>•简称SVI接口；</p><p>•它们所在的网段作为直连路由填充在路由表中；</p><p>•虚拟VLAN接口就十分适合充当该VLAN所连接设备的网关。</p><h4 id="网络排错的几大步骤："><a href="#网络排错的几大步骤：" class="headerlink" title="网络排错的几大步骤："></a>网络排错的几大步骤：</h4><p>•收集故障信息；</p><p>•定位故障点；</p><p>•提出解决方案并进行测试；</p><p>•实施变更并进行测试。</p><h3 id="第六章-动态路由"><a href="#第六章-动态路由" class="headerlink" title="第六章 动态路由"></a>第六章 动态路由</h3><p>距离矢量型路由协议</p><p>链路状态型路由协议</p><p>l两类路由协议的比较：</p><p>•运行距离矢量型路由协议的路由器只拥有自己周围这几台路由器分享的距离和矢量信息；</p><p>运行链路状态型路由协议的路由器则像是在每个路口为远足者提供一张完整的区域地图</p><p>从路由协议在发送路由更新信息时是否会携带掩码，将路由协议分为：</p><p>•有类路由协议；</p><p>•无类路由协议。</p><p><img src="C:\Users\陌生的回忆\AppData\Roaming\Typora\typora-user-images\1620786802745.png" alt="1620786802745"></p><p><img src="C:\Users\陌生的回忆\AppData\Roaming\Typora\typora-user-images\1620786837422.png" alt="1620786837422"></p><p><img src="C:\Users\陌生的回忆\AppData\Roaming\Typora\typora-user-images\1620787052688.png" alt="1620787052688"></p><p>AR1通过有类路由协议RIPv1发送的路由更新，学习到了一条关于网络22.0.0.0/8的路由信息。之所以AR1添加到自己IPv4路由表中的条目不是22.1.1.0/24，是因为AR2在通告路由时，需要首先判断发送路由更新的接口IP地址和该更新消息中的网络地址是否在同一个主类网络中。经过判断，AR2发现自己用来发送这条路由的E0接口IP地址12.1.1.2属于12.0.0.0/8这个A类网络，而22.1.1.0/24这条路由则属于22.0.0.0/8这个A类网络，它们并不处于同一个主类网络中，于是AR2将这条路由汇总为了主类网络22.0.0.0/8发送给了AR1。</p><p>然而，AR2收到AR1发送的RIPv1路由更新消息，却可以学习到关于子网12.1.2.0/24的信息。这是因为，AR1在通告路由时，发现发送路由更新的接口IP地址（12.1.1.1）和该路由的网络地址（12.1.2.0）都处于主类网络12.0.0.0/8中；同时，这条路由的子网掩码和AR1 E0接口的掩码都是24位。于是，AR1直接发送了去往子网12.1.2.0的路由更新，而不会将它汇总为主类网络。在AR2接收到更新消息时，AR2发现自己接收这条路由更新的E0接口IP地址（12.1.1.2）与该路由的网络地址（12.1.2.0/24）都处于12.0.0.0这个A类网络中；同时，路由器用自己E0接口的24位掩码匹配12.1.2.0这个网络地址，发现主机位全部为0，于是AR2就将E0接口的24位掩码赋予了12.1.2.0这条路由，将12.1.2.0/24作为路由条目保存进了自己的IPv4路由表中。</p><p>如果AR2的E1接口连接了另一台路由器AR3，我们就可以在AR2向AR3发送路由更新时，更加清晰地看到跨越主类网络边界的含义。此时，AR2通告给AR3的有关12.1.2.0/24与12.1.1.0/24这两条路由前缀都会被汇总为同一主类网络。于是，AR3的路由表中也就只有12.0.0.0/8这一条主类网络路由。</p><h4 id="距离矢量型路由协议"><a href="#距离矢量型路由协议" class="headerlink" title="距离矢量型路由协议"></a>距离矢量型路由协议</h4><p>•易配置；</p><p>•具备动态路由协议的扩展性和应变能力；</p><p>•能够自动学习路由、选择路由；</p><p>•避免网络中出现环路；</p><p>路由通告方式是周期更新</p><p>l交换信息</p><p>•节点所知的全网可达信息－－交换路由表（路由转发表）</p><p>•路由信息：目的＋距离（节点个数）</p><p> －－即通过“我”能到达哪些节点，有多远</p><p>l交换方式</p><p>•仅与相邻节点交换，定期交换</p><p>•与相邻路由器交换全网路由信息</p><p>l最佳路由计算方式</p><p>•每个节点告诉“我”的，都是他们的最佳路由。</p><p>•根据当前已知的，对比新知道的，算出最好的</p><p>•当前知道：到D经过C，总距离为5</p><p>•新了解到：B告诉“我”，经过他到D距离为2</p><p>•“我”到B的距离为2， 所以“我”到D的路由更新为：经过B到D，路由距离为4</p><p><img src="C:\Users\陌生的回忆\AppData\Roaming\Typora\typora-user-images\1620787862169.png" alt="1620787862169"></p><p>l网络中出现了接口状态变化，环路隐患</p><h4 id="RIPv1-amp-RIPv2"><a href="#RIPv1-amp-RIPv2" class="headerlink" title="RIPv1&amp;RIPv2"></a>RIPv1&amp;RIPv2</h4><p>l与RIPv2相比，RIPv1的缺陷有：</p><p>•典型的有类路由协议；</p><p>•采用广播进行周期更新；</p><p>•无法认证身份。</p><p>l广播更新：只要一个广播域中有启用了RIPv1的接口，那么这个广播域中没有启用RIPv1的设备也必须频繁地处理RIPv1路由器发送的广播更新消息，尽管这些更新与它们实际上毫无干系。这种做法无疑增加了无关设备的开销。</p><p>lRIP协议的特性：</p><p>•RIP协议（无论RIPv1还是RIPv2）是基于UDP的应用层协议，RIP对应的端口号是UDP 520；</p><p>•RIPv1封装的RIP消息，其目的地址也就是255.255.255.255；</p><p>•RIPv2在发送RIP消息时，<em><strong>封装的目的IP地址为组播地址224.0.0.9。</strong></em></p><h4 id="RIP的环路避免机制"><a href="#RIP的环路避免机制" class="headerlink" title="RIP的环路避免机制"></a>RIP的环路避免机制</h4><p>•水平分割（Split Horizon）引入的规则是，禁止路由器将从一个接口学习到的路由，再从同一个接口通告出去。</p><p>​    毒性反转的做法是，当路由器从一个接口学习到一条去往某个网络路由时，它就会通过这个接口通告一条该网络不可达的路由  </p><p>•路由毒化（Route Poisoning）是指路由器会将自己路由表中已经失效的路由作为一条不可达路由主动通告出去；</p><p>•触发更新（Triggered Update）顾名思义，是指路由器在网络发生变化时，不等待更新计时器到时，就主动发送更新。</p><p>路由毒化和触发更新这两种机制结合在一起，可以迅速将网络出现了变化的消息通告给网络中的其他路由器，避免网络在等待计时器过期的过程中出现环路。</p><p>OSPF（开放最短路径优先）</p><p>三个要点：</p><ul><li>向本自治系统中所有路由器发送信息，这里使用的方法是洪泛法。</li><li>发送的信息就是与本路由器相邻的所有路由器的链路状态，但这只是路由器所知道的部分信息。</li><li>“链路状态”就是说明本路由器都和哪些路由器相邻，以及该链路的“度量”(metric)。 </li><li>只有当链路状态发生变化时，路由器才用洪泛法向所有路由器发送此信息</li></ul><p>​     。OSPF 的更新过程收敛得快是其重要优点。   </p><p>OSPF 不用 UDP 而是直接用 IP 数据报传送。</p><p>​     设备的接口如果未启用为接收 OSPF 数据包，则会忽略这些数据包。这样可节省非 OSPF 设备的 CPU 处理时间。  </p><p><img src="C:\Users\陌生的回忆\AppData\Roaming\Typora\typora-user-images\1620803341183.png" alt="1620803341183"></p><p>问题1：</p><p>距离矢量路由协议是通过路由器向其邻居发送自己的路由表的方式来维护自己本身的路由信息；而链路状态协议从网络或者网络的限定区域内的所有其他路由器处（不仅仅限制在自己的邻居路由器处）收集信息。收集完信息之后，每台路由器会在不依赖其他路由器的情况下计算到达各个网络的路由，由于每台路由器维护的是其对整个网络的印象，因此路由器不太会传播邻居路由器提供的错误信息</p><p>链路状态路由协议是收集整个网络的各种信息，所以，这些信息就构成了路由器的一个拓扑数据库。通过对这个数据库使用DijkstraSPF树，这样就能找到通往目的地的最佳路径。</p><p>问题2：</p><p>首先，路由器将自己视为整个网络的根，同时把与自己直连的邻居节点添加到这个树状拓扑中，其他非直连的节点则会被添加到一个候选列表中。</p><p>接下来，算法会将每个候选列表中的节点与树状拓扑中的节点进行比较，如果有哪个候选节点与树状拓扑中当前任何一个邻居节点之间的开销值最小，那么算法会将这个节点作为该节点的邻居节点添加到树状拓扑中，同时将其从候选节点列表中删除。</p><p>这个算法会不断重复，直至候选列表中的所有节点都被添加到了树状拓扑中为止。</p><h3 id="网络工程基础"><a href="#网络工程基础" class="headerlink" title="网络工程基础"></a>网络工程基础</h3><h4 id="网络工程的含义："><a href="#网络工程的含义：" class="headerlink" title="网络工程的含义："></a>网络工程的含义：</h4><p>采用信息系统工程方法，在完善的组织机构的领导下，根据用户的需求，按照计算机网络系统的标准，详细规划设计方案，建成一个满足用户需求的计算机网络系统</p><p>甲方：招标</p><p>乙方：投标</p><p>监理方：提供帮助</p><h4 id="网络规划与设计："><a href="#网络规划与设计：" class="headerlink" title="网络规划与设计："></a>网络规划与设计：</h4><ul><li>需求分析</li><li>总体设计</li><li>详细设计</li><li>施工及验收</li><li>服务及培训</li></ul><h4 id="招标："><a href="#招标：" class="headerlink" title="招标："></a>招标：</h4><ul><li>公开招标</li><li>邀请招标</li><li>竞争性谈判</li><li>唯一来源采购</li><li>询价</li></ul><p>s</p>]]></content>
    
    
    <categories>
      
      <category>复习资料</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络工程</tag>
      
      <tag>复习</tag>
      
      <tag>路由与交换</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>我的第一篇博客</title>
    <link href="/2021/06/21/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/"/>
    <url>/2021/06/21/%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><h1 id="第一天"><a href="#第一天" class="headerlink" title="第一天"></a>第一天</h1><h3 id="1-封装"><a href="#1-封装" class="headerlink" title="1.封装"></a>1.封装</h3><h3 id="2-继承"><a href="#2-继承" class="headerlink" title="2.继承"></a>2.继承</h3><h3 id="3-多态"><a href="#3-多态" class="headerlink" title="3.多态"></a>3.多态</h3>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2021/06/21/hello-world/"/>
    <url>/2021/06/21/hello-world/</url>
    
    <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><script class="meting-secondary-script-marker" src="\assets\js\Meting.min.js"></script><p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
